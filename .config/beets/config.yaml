directory: ~/Music/

library: ~/Music/.beets/library.db

art_filename: cover
format_album: $path
format_item: $path

ignore: []
ignore_hidden: yes

per_disc_numbering: no

sort_album: path+
sort_item: path+
sort_case_insensitive: yes

threaded: yes
timeout: 5.0
verbose: no

va_name: 'Various Artists'

plugins:
  - info
  - inline
  - convert
  - duplicates
  - edit
  - export
  - web
  - fish
  - fetchart
  - embedart
  - lyrics
  - lastgenre
  - thumbnails
  - albumtypes
  - musicbrainz
  - deezer
  - spotify

replace:
    '[\\]':         ''
    '[_]':          '-'
    '[/]':          '-'
    '^\.':          ''
    '[\x00-\x1f]':  ''
    '[<>:"\?\*\|]': ''
    '\.$':          ''
    '\s+$':         ''
    '^\s+':         ''
    '^-':           ''
    '’':            "'"
    '′':            "'"
    '″':            ''
    '‐':            '-'

duplicates:
  album: yes
  count: yes
  delete: no
  full: yes
  move: path
  path: yes
  strict: no
  tiebreak:
    items:
      - bitrate

import:
  default_action: apply
  non_rec_action: asis
  duplicate_action: skip
  autotag: yes
  write: yes
  copy: no
  link: no
  move: yes
  resume: ask
  incremental: yes
  log: ~/Music/.beets/beet.log

edit:
  itemfields:
    - track
    - title
    - artist
    - album
    - year
  albumfields:
    - track
    - title
    - artist
    - albumartist
    - album
    - year

embedart:
  auto: yes
  ifempty: no
  remove_art_file: no

fetchart:
  sources:
    - coverart: release
    - coverart: releasegroup
    - albumart
    - amazon
    - google
    - itunes
    - fanarttv
    - lastfm
    - wikipedia
  auto: yes
  cautious: yes
  minwidth: 500
  maxwidth: 1200
  cover_format: jpeg
  store_source: yes

inline:
  auto: true

ftintitle:
  auto: yes

item_fields:
  fmt: |
    if format.lower() == 'flac':
      return ' [FLAC]'
    else:
      return None

  padded_tracknr: "'{:02n}'.format(track)"

  moh_catalog: catalognum.replace(" ", "")

  first_artist: |
    # import an album to another artists directory, like:
    # Tom Jones │1999│ Burning Down the House [Single, CD, FLAC]
    # to The Cardigans/+singles/Tom Jones & the Cardigans │1999│ Burning Down the House [Single, CD, FLAC]
    # https://github.com/beetbox/beets/discussions/4012#discussioncomment-1021414
    # beet import --set myartist='The Cardigans'
    # we must first check to see if myartist is defined, that is, given on
    # import time, or we raise an NameError exception.
    try:
      myartist
    except NameError:
      import re
      return re.split(',|\\s+(feat(.?|uring)|&|(Vs|Ft).)', albumartist, 1, flags=re.IGNORECASE)[0]
    else:
      return myartist

  first_artist_singleton: |
    try:
      myartist
    except NameError:
      import re
      return re.split(',|\\s+(feat(.?|uring)|&|(Vs|Ft).)', artist, 1, flags=re.IGNORECASE)[0]
    else:
      return myartist

  base_name: |
    import os.path
    base = os.path.basename(path)
    return os.path.splitext(base)[0]

album_fields:
  cdtype: u'[%s]' % (albumtype.lower()) if albumtype else u''

  notalbum: 0 if albumtype and albumtype.lower() == 'album' else 1

  source: |
      media = set([i.media.lower() for i in items])
      format = set([i.format for i in items])
      tbr = sum([i.bitrate for i in items])
      abr = tbr / len(items) / 1000
      bitdepth = sum([i.bitdepth for i in items]) // len(items)

      # Init output
      o = [f for f in format] if format else []

      # Handle bitrate categories
      for f in format:
          if f == 'FLAC':
              o.append(str(bitdepth) + 'bit')

      if abr < 480 and abr >= 320:
          o.append('320')
      elif abr < 320 and abr >= 220:
          o.append('V0')
      elif abr < 215 and abr >= 170 and abr != 192:
          o.append('V2')
      elif abr == 192:
          o.append('192')
      elif abr < 170:
          o.append(str(abr))

      # Handle media aliases
      for m in media:
          if any(t in m for t in ('digital', 'file')):
              o.append('WEB')
          elif 'vinyl' in m:
              o.append('Vinyl')
          elif 'cd' in m:
              o.append('CD')
          elif m != '':
              o.append(m)

      return ", ".join(o)

  mixtape_album: |
    import re
    album_fixed = album
    return re.sub(r"G.unit Radio,?\s+(Pt|Part)[.]?\s*(.*)", r"G-Unit Radio \2", album_fixed, flags=re.IGNORECASE)

  alb_status: |
    # MB returns 4 values describing how "offical" a release is, they are:
    # Official, Promotional, Bootleg, and Pseudo-Release
    # We only note the middle two.
    # https://musicbrainz.org/doc/Release#Status
    if 'Promo' in albumstatus:
      return 'Promo, '
    elif 'Bootleg' in albumstatus:
      return 'Bootleg, '
    elif 'Official' in albumstatus:
      return 'Official, '
    elif 'Promotion' in albumstatus:
      return 'Promo, '
    else:
      return None

  alb_type: |
    alb_types = ""
    albumtypes_list = {
      'ep': 'EP',
      'lp': 'LP',
      'single': 'Single',
      'live': 'Live',
      'remix': 'Remix',
      'dj-mix': 'DJ-mix',
      'mixtape/street': 'Mixtape',
      'interview': 'Interview',
    }
    for key, value in albumtypes_list.items():
      if albumtype == key:
        alb_types += str(value)

      if alb_types is not None:
        if alb_types != '':
          return alb_types + ', '
      else:
        return None

  media_type: |
      # https://musicbrainz.org/doc/Release/Format
      # Lets Merge the variations of the same medium into the main
      # medium name (Opinonated)
      media_list = {
       '12" Vinyl':     'Vinyl',
       '10" Vinyl':     'Vinyl',
       '7" Vinyl':      'Vinyl',
       'Vinyl':         'Vinyl',
       'CDr':           'CDR',
       'CD-R':          'CDR',
       'Cassette':      'Cassette',
       'Digital Media': 'Web',
       'CD':            'CD',
       'File':          'Web',
       'DVD':           'DVDA',
      }
      # Lets omit these instead of converging them under a similar label like above (Opinonated)
      media_types_to_omit = ['Blu-spec CD']
      if items[0].media in media_list:
        return str(media_list[items[0].media]) + ', '
      elif items[0].media in media_types_to_omit:
        return None
      elif items[0].media == '':
        return None
      else:
        return str(items[0].media) + ', '

  hasyear: 1 if year > 0 else 0

match:
  strong_rec_thresh: 0.08
  # required:
  #   - year
  #   - label
  #   - country
  ignored: missing_tracks unmatched_tracks

ui:
  color: yes

aunique:
  keys:
    - albumartist
    - albumtype
    - year
    - album
  disambuguators:
    - format
    - mastering
    - media
    - label
    - albumdisambig
    - releasegroupdisambig
  bracket: []

paths:
  default: Albums/$first_artist - $album/${padded_tracknr} - $title
  albumtype:single: Singles/$first_artist_singleton - $title
  albumtype:compilation: Compilations/$album/${padded_tracknr} - $title
  albumtype:soundtrack: Soundtracks/$album/${padded_tracknr} - $title

lastgenre:
  auto:      yes
  canonical: yes
  force:     no
  source:    artist

lyrics:
  auto: yes
  force: no
  synced: yes
  sources:
    - genius
    - google
    - lrclib
    - lyrics.com
    - lyricwiki
    - musixmatch
    - tekstowo

musicbrainz:
  extra_tags:
    - year
    - originalyear
    - catalognum
    - country
    - media
    - label

convert:
  auto: no
  dest: ~/Music/.beets/converted
  opts: -ab 320k -ac 2 -ar 48000
  max_bitrate: 320
  never_convert_lossy_files: yes
