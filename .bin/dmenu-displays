#!/usr/bin/env bash
# display-menu: interactive xrandr manager with two-stage UI, smart defaults and config
# Features:
#  - Two-stage menu: pick display -> pick action
#  - Works with dmenu or dmenu-picker wrapper
#  - Detects laptop/internal display (eDP/LVDS/DSI) and external monitors
#  - Actions: Enable, Disable, Set Primary, Set Mode, Mirror Primary, Place Left/Right/Above/Below, Rotate
#  - Asks when enabling externals whether to disable laptop and where to place them
#  - Optional config file (~/.config/display-menu/config)
#
# User choices set: Ask each time about auto-disable, ask each time where to position, Mirror included.
set -euo pipefail

# ---------- Configuration & defaults ----------
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/display-menu/config"

# Default dmenu fonts/colors can be overridden in config
DEFAULTS=(
  "auto_disable_on_external=ask"   # ask|yes|no (we'll honor ask)
  "default_position=ask"           # right|left|above|below|ask
  "dmenu_font=Maple Mono NF:regular:pixelsize=14"
  "dmenu_lines=10"
)

# Load config if available (simple KEY=VALUE format)
declare -A CFG
for kv in "${DEFAULTS[@]}"; do
  k="${kv%%=*}"; v="${kv#*=}"
  CFG["$k"]="$v"
done

if [ -f "$CONFIG_FILE" ]; then
  while IFS='=' read -r key val; do
    key_trimmed="$(echo "$key" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    val_trimmed="$(echo "$val" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    [ -z "$key_trimmed" ] && continue
    CFG["$key_trimmed"]="$val_trimmed"
  done < "$CONFIG_FILE"
fi

# ---------- Detect menu program ----------
DMU_CMD="dmenu"
if command -v dmenu-picker &>/dev/null; then
    DMU_CMD="dmenu-picker"
fi

# ---------- Helper: menu (works with dmenu and dmenu-picker) ----------
menu() {
  local prompt="$1"; shift
  local lines="${CFG[dmenu_lines]}"
  if [ "$DMU_CMD" = "dmenu" ]; then
    printf "%s\n" "$@" | dmenu -i -l "$lines" -p "$prompt" -fn "${CFG[dmenu_font]}"
  else
    # dmenu-picker wrapper expects prompt then options as args
    dmenu-picker "$prompt" "$@"
  fi
}

# ---------- Parse xrandr output into associative arrays ----------
declare -A STATUS        # connected|disconnected
declare -A PRIMARY       # 1 if primary else 0
declare -A MODES         # space-separated list of modes for each display
declare -A CURRENT_MODE  # current mode (resolution) for connected displays
declare -A CONNECTED_ORDER # order of appearance
order=0

current=""
while IFS= read -r line; do
  # Header lines: e.g. "eDP-1 connected primary 1920x1080+0+0 ..."
  if [[ "$line" =~ ^([A-Za-z0-9-]+)\ (connected|disconnected) ]]; then
    current="${BASH_REMATCH[1]}"
    STATUS["$current"]="${BASH_REMATCH[2]}"
    PRIMARY["$current"]=$([[ "$line" =~ primary ]] && echo 1 || echo 0)
    # Attempt to detect current mode like "1920x1080+0+0" -> 1920x1080
    if [[ "$line" =~ ([0-9]+x[0-9]+)\+ ]]; then
      CURRENT_MODE["$current"]="${BASH_REMATCH[1]}"
    else
      CURRENT_MODE["$current"]=""
    fi
    MODES["$current"]=""
    CONNECTED_ORDER["$order"]="$current"
    order=$((order+1))
  elif [[ "$line" =~ ^[[:space:]]*([0-9]+x[0-9]+) ]]; then
    # Resolution line (mode)
    m="${BASH_REMATCH[1]}"
    # Append mode
    MODES["$current"]+="$m "
  fi
done < <(xrandr --query)

# Determine primary display and its mode
primary_disp=""
primary_mode=""
for d in "${!PRIMARY[@]}"; do
  if [ "${PRIMARY[$d]}" -eq 1 ]; then
    primary_disp="$d"
    primary_mode="${CURRENT_MODE[$d]:-}"
    break
  fi
done

# Helper detect internal laptop display (eDP/LVDS/DSI heuristics)
detect_internal() {
  for d in "${!STATUS[@]}"; do
    if [[ "$d" =~ ^eDP-|^LVDS-|^DSI- ]]; then
      echo "$d"
      return 0
    fi
  done
  # Fallback: smallest resolution among connected screens (heuristic)
  smallest=""
  smallest_area=0
  for d in "${!STATUS[@]}"; do
    if [ "${STATUS[$d]}" = "connected" ]; then
      cmode="${CURRENT_MODE[$d]}"
      if [[ $cmode =~ ^([0-9]+)x([0-9]+)$ ]]; then
        w=${BASH_REMATCH[1]}; h=${BASH_REMATCH[2]}
        area=$((w*h))
        if [ -z "$smallest" ] || [ "$area" -lt "$smallest_area" ]; then
          smallest="$d"; smallest_area="$area"
        fi
      fi
    fi
  done
  if [ -n "$smallest" ]; then
    echo "$smallest"
  else
    echo ""  # none found
  fi
}

LAPTOP=$(detect_internal)

# ---------- Build display selection menu ----------
display_opts=()
for idx in $(seq 0 $((order-1))); do
  d="${CONNECTED_ORDER[$idx]}"
  [ -z "$d" ] && continue
  tag="${STATUS[$d]}"
  emoji="ó°¹ "
  if [ "$d" = "$LAPTOP" ]; then
    emoji="ó°Œ¢ "
  fi
  if [ "${PRIMARY[$d]:-0}" -eq 1 ]; then
    tag="$tag, primary"
    emoji="ï€… $emoji"
  fi
  if [ "${STATUS[$d]}" = "disconnected" ]; then
    emoji="ó±¤ $emoji"
  else
    emoji="ó±¥ $emoji"
  fi
  curm="${CURRENT_MODE[$d]:-unknown}"
  display_opts+=("$emoji $d ($tag) â€” $curm")
done

# If no displays found exit
if [ "${#display_opts[@]}" -eq 0 ]; then
  echo "No displays detected." >&2
  exit 1
fi

chosen_display_line=$(menu "Select Display:" "${display_opts[@]}") || exit 0
# Extract the display name (second token)
# chosen_display_line example: "ðŸ’» eDP-1 (connected, primary) â€” 1920x1080"
chosen_display=$(awk '{for(i=1;i<=NF;i++) if($i ~ /^[A-Za-z0-9-]+$/) {print $i; exit}}' <<< "$chosen_display_line")

# ---------- Build action menu for selected display ----------
action_opts=()
if [ "${STATUS[$chosen_display]}" = "connected" ]; then
  action_opts+=("Disable")
  if [ "${PRIMARY[$chosen_display]:-0}" -eq 0 ]; then
    action_opts+=("Set Primary")
  fi
  # Mirror primary if primary exists and different displays
  if [ -n "$primary_disp" ] && [ "$primary_disp" != "$chosen_display" ]; then
    action_opts+=("Mirror Primary ($primary_disp)")
  fi
  # Placement actions (relative to primary) - only makes sense if there is a primary and it is different
  if [ -n "$primary_disp" ] && [ "$primary_disp" != "$chosen_display" ]; then
    action_opts+=("Place Right of $primary_disp")
    action_opts+=("Place Left of $primary_disp")
    action_opts+=("Place Above $primary_disp")
    action_opts+=("Place Below $primary_disp")
  fi
  # Modes
  for m in ${MODES[$chosen_display]}; do
    action_opts+=("Set Mode $m")
  done
  # Rotation options
  action_opts+=("Rotate normal")
  action_opts+=("Rotate left")
  action_opts+=("Rotate right")
  action_opts+=("Rotate inverted")
else
  # disconnected
  action_opts+=("Enable")
fi

chosen_action=$(menu "Select Action for $chosen_display:" "${action_opts[@]}") || exit 0

# ---------- Helper functions for actions ----------
run_xrandr() {
  echo "Running: xrandr $*" >&2
  xrandr "$@"
}

# Helper to ask yes/no via dmenu
ask_yes_no() {
  local q="$1"
  local ans
  ans=$(menu "$q" "Yes" "No") || echo "No"
  echo "$ans"
}

# Helper to ask position if needed
ask_position() {
  local q="$1"
  local pos
  pos=$(menu "$q" "right" "left" "above" "below" "ask no placement (keep relative)")
  echo "$pos"
}

# Get primary if changed
update_primary_info() {
  primary_disp=""
  primary_mode=""
  for d in "${!PRIMARY[@]}"; do
    if [ "${PRIMARY[$d]}" -eq 1 ]; then
      primary_disp="$d"
      primary_mode="${CURRENT_MODE[$d]:-}"
      return 0
    fi
  done
}

# ---------- Execute chosen action ----------
if [[ "$chosen_action" == "Enable" ]]; then
  # When enabling: ask whether to auto-disable laptop (user choice: ask-every-time)
  # Ask for mode: pick preferred: primary_mode if available else auto
  # Ask where to place (since user chose ask-every-time)
  # Steps:
  #  1. Choose mode (list modes + "auto")
  #  2. Ask position (right/left/above/below/none)
  #  3. Ask whether to disable laptop (if laptop exists and different)
  modes_list=(${MODES[$chosen_display]})
  mode_choice="auto"
  if [ "${#modes_list[@]}" -gt 0 ]; then
    # prepare mode menu: show "auto" + modes
    mode_sel=$(menu "Choose mode for $chosen_display (auto tries --auto):" "auto" "${modes_list[@]}") || mode_sel="auto"
    mode_choice="$mode_sel"
  fi

  # Position (ask-every-time)
  pos_choice=$(ask_position "Where place $chosen_display relative to primary ($primary_disp)?")
  # If user picked "ask no placement" we set pos_choice to empty
  [ "$pos_choice" = "ask no placement (keep relative)" ] && pos_choice=""

  disable_laptop="No"
  if [ -n "$LAPTOP" ] && [ "$LAPTOP" != "$chosen_display" ]; then
    ans=$(ask_yes_no "Disable laptop display $LAPTOP when enabling $chosen_display?")
    disable_laptop="$ans"
  fi

  # Build xrandr args
  xcmd=(--output "$chosen_display")
  if [ "$mode_choice" != "auto" ] && [ -n "$mode_choice" ]; then
    xcmd+=(--mode "$mode_choice" --auto)
  else
    xcmd+=(--auto)
  fi

  # If position chosen and primary exists, apply position flags
  # ensure we have up-to-date primary info
  update_primary_info
  if [ -n "$pos_choice" ] && [ -n "$primary_disp" ]; then
    case "$pos_choice" in
      right) xcmd+=(--right-of "$primary_disp") ;;
      left)  xcmd+=(--left-of "$primary_disp") ;;
      above) xcmd+=(--above "$primary_disp") ;;
      below) xcmd+=(--below "$primary_disp") ;;
    esac
  fi

  run_xrandr "${xcmd[@]}"

  # Optional: if user requested disabling laptop
  if [ "$disable_laptop" = "Yes" ]; then
    if [ -n "$LAPTOP" ]; then
      run_xrandr --output "$LAPTOP" --off
    fi
  fi

elif [[ "$chosen_action" == "Disable" ]]; then
  run_xrandr --output "$chosen_display" --off

elif [[ "$chosen_action" == "Set Primary" ]]; then
  run_xrandr --output "$chosen_display" --primary

elif [[ "$chosen_action" == Mirror\ Primary* ]]; then
  # Mirror primary: set same mode as primary and use --same-as
  # ensure primary exists
  if [ -z "$primary_disp" ] || [ "$primary_disp" = "$chosen_display" ]; then
    echo "No other primary display to mirror." >&2
    exit 1
  fi
  # pick a suitable mode: prefer primary_mode; fallback to chosen display's first mode
  mode_to_set="${primary_mode}"
  if [ -z "$mode_to_set" ]; then
    # get primary mode from xrandr
    primary_mode_line=$(xrandr --query | awk -v p="$primary_disp" '$1==p {for(i=1;i<=NF;i++) if($i ~ /[0-9]+x[0-9]+\+/) {split($i,a,"+"); print a[1]; exit}}')
    mode_to_set="${primary_mode_line:-}"
  fi
  if [ -z "$mode_to_set" ]; then
    # fallback: choose first mode available on chosen_display
    for mm in ${MODES[$chosen_display]}; do mode_to_set="$mm"; break; done
  fi
  if [ -z "$mode_to_set" ]; then
    echo "No mode found to mirror." >&2
    exit 1
  fi
  # Set chosen_display to that mode and mirror
  run_xrandr --output "$chosen_display" --mode "$mode_to_set" --same-as "$primary_disp"

elif [[ "$chosen_action" == Place\ * ]]; then
  # Format: Place Right of <primary_disp>
  # Extract direction and target
  # e.g. "Place Right of eDP-1"
  dir=$(awk '{print $2}' <<< "$chosen_action" | tr '[:upper:]' '[:lower:]')
  target=$(awk '{print $4}' <<< "$chosen_action")
  case "$dir" in
    right) run_xrandr --output "$chosen_display" --right-of "$target" --auto ;;
    left)  run_xrandr --output "$chosen_display" --left-of "$target" --auto ;;
    above) run_xrandr --output "$chosen_display" --above "$target" --auto ;;
    below) run_xrandr --output "$chosen_display" --below "$target" --auto ;;
    *) echo "Unknown place direction: $dir" >&2; exit 1 ;;
  esac

elif [[ "$chosen_action" == Set\ Mode\ * ]]; then
  mode="${chosen_action#Set Mode }"
  run_xrandr --output "$chosen_display" --mode "$mode"

elif [[ "$chosen_action" == Rotate\ * ]]; then
  rot="${chosen_action#Rotate }"
  # Normalize the token
  case "$rot" in
    normal|left|right|inverted) run_xrandr --output "$chosen_display" --rotate "$rot" ;;
    *) echo "Unknown rotation: $rot" >&2; exit 1 ;;
  esac

else
  echo "Unknown action: $chosen_action" >&2
  exit 1
fi

# Done
exit 0
